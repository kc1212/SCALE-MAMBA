"""
This file the demo reference.
During the demo we'll start with the reference.py file.
Then slowly convert it to a .mpc file and then run it in SCALE.
The conversion will follow the following steps.
1. Setup open_channel_with_return/close_channel
2. Setup arrays for holding xs and ys
3. Read the input, remember to convert it to sfix
4. Update the gradient_descent_mse function to take MemValue for m/c and cfix for alpha
5. Write the print function to show the results
6. Convert dfdc and dfdm (use register, write for_range)
7. Convert gradient_descent_mse in a similar way
8. Add start_timer/stop_timer
9. Compile to make sure nothing is wrong
10. Briefly show the float_to_int script
11. Run in SCALE
"""


def dfdc(n, zs, reg):
    reg.write(sfix(0))
    @for_range(n)
    def body(i):
        reg.write(reg.read() + zs[i])
    reg.write(reg.read() * (-2.0/n))


def dfdm(n, zs, xs, reg):
    reg.write(sfix(0))
    @for_range(n)
    def body(i):
        reg.write(reg.read() + zs[i]*xs[i])
    reg.write(reg.read() * (-2.0/n))


def gradient_descent_mse(n, xs, ys, m, c, alpha, iters):
    tmp_m = MemValue(sfix(0))
    tmp_c = MemValue(sfix(0))
    zs = Array(n, sfix) # for computing ys[i] - (m*xs[i] + c)

    @for_range(iters)
    def body(i):
        @for_range(n)
        def inner_body(j):
            zs[j] = ys[j] - (m.read()*xs[j] + c.read())
        dfdm(n, zs, xs, tmp_m)
        dfdc(n, zs, tmp_c)
        m.write(m.read() - alpha*tmp_m)
        c.write(c.read() - alpha*tmp_c)

    return m, c


n = 10

start_timer(0)

open_channel_with_return(0)

xs = Array(n, sfix)
@for_range(n)
def body(i):
    xs[i] = sfix(sint.get_private_input_from(0))

ys = Array(n, sfix)
@for_range(n)
def body(i):
    ys[i] = sfix(sint.get_private_input_from(1))

close_channel(0)

m, c = gradient_descent_mse(n, xs, ys, MemValue(sfix(0.0)), MemValue(sfix(5.0)), cfix(0.0002), 10)
print_ln("\n\tm: %s, c: %s", m.read().reveal(), c.read().reveal())

stop_timer(0)
