def dfdc(n, inner, reg):
    # lambda inner: (-2/n)*sum(inner)
    reg.write(sfix(0))
    @for_range(n)
    def body(i):
        reg.write(reg.read() + inner[i])
    reg.write(reg.read() * (-2.0/n))


def dfdm(n, inner, xs, reg):
    # lambda inner: (-2/n)*sum([t*x for (t, x) in zip(inner, xs)])
    reg.write(sfix(0))
    @for_range(n)
    def body(i):
        reg.write(reg.read() + inner[i]*xs[i])
    reg.write(reg.read() * (-2.0/n))


def gradient_descent_mse(n, xs, ys, m, c, alpha_m, alpha_c, iters=100):
    """
    Gradient descent algorithm for the mean squared error
    f(m, c) = (1/n) * sum(yi - (m * xi + c))^2
    """

    tmp_m = MemValue(sfix(0))
    tmp_c = MemValue(sfix(0))
    inner = Array(n, sfix) # for computing ys[i] - (m*xs[i] + c)

    @for_range(iters)
    def body(i):
        @for_range(n)
        def inner_body(j):
            inner[j] = ys[j] - (m.read()*xs[j] + c.read())
        dfdm(n, inner, xs, tmp_m)
        dfdc(n, inner, tmp_c)
        m.write(m.read() - alpha_m*tmp_m)
        c.write(c.read() - alpha_c*tmp_c)

    return m, c


n = 10

open_channel_with_return(0)

xs = Array(n, sfix)
@for_range(n)
def body(i):
    xs[i] = sfix(sint.get_private_input_from(0))

ys = Array(n, sfix)
@for_range(n)
def body(i):
    ys[i] = sfix(sint.get_private_input_from(1))

close_channel(0)

m, c = gradient_descent_mse(10, xs, ys, MemValue(sfix(0.0)), MemValue(sfix(0.0)), cfix(0.0001), cfix(0.01), 20)
print_ln("\n\tOUTPUT: m: %s, c: %s", m.read().reveal(), c.read().reveal())
